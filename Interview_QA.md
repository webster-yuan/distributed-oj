# 负载均衡式 OJ 项目面试常见问题解答 (QA)

本文档整理了在面试过程中，针对该项目可能被问到的核心技术问题及参考答案。

## 1. 项目整体架构相关

**Q: 请简述一下该项目的架构设计？**
A: 本项目采用分布式微服务架构的思想，将系统分为两个核心模块：`oj_server`（业务与调度中心）和 `compile_server`（判题后端）。
- `oj_server` 负责用户交互、题库管理、负载均衡分发，采用 MVC 模式（Model 负责数据库操作，View 使用 `ctemplate` 渲染网页，Control 负责业务逻辑）。
- `compile_server` 专注于底层的编译与运行，两者通过基于 HTTP 的 JSON 接口进行通信，实现了业务与判题逻辑的完全解耦。

**Q: 为什么选择 C++ 作为开发语言？**
A: 1. **性能优势**：在线判题系统对响应时间要求很高，C++ 能够提供接近底层的运行速度。
2. **系统接口支持**：本项目深度依赖 Linux 系统调用（如 `fork`, `exec`, `setrlimit` 等）进行资源管理和进程控制，C++ 调用这些接口非常自然且高效。
3. **主流性**：大多数 OJ 系统本身就需要支持 C++ 判题，用 C++ 开发后端更易于集成编译器和处理运行环境。

## 2. 负载均衡相关

**Q: 你的负载均衡算法是如何实现的？**
A: 本项目实现了一个基于动态负载评估的调度算法。
1. **状态监控**：每个后端节点（Machine）会周期性地或在请求前上报其当前的资源状态（包括 CPU 使用率、内存占用、当前连接数等）。
2. **综合分值计算**：系统根据预设权重（如 CPU 占 40%，内存占 20% 等）计算出一个综合负载得分。
3. **最小负载优先**：`oj_server` 维护一个在线服务器列表，每次分发判题任务时，遍历列表选择当前综合负载得分最低的机器。
4. **容错处理**：如果某台机器请求失败，负载均衡器会自动将其暂时剔除（Offline），并尝试分发给其他机器。

## 3. 安全与资源限制相关

**Q: 如何保证用户提交的恶意代码不会挂掉你的服务器？**
A: 这是 OJ 系统的核心安全问题。本项目主要通过以下手段解决：
1. **进程隔离**：使用 `fork` 为每个判题请求创建一个独立的子进程，用户代码在子进程中运行。即使崩溃或触发异常，也不会影响主服务的运行。
2. **资源限制（Sandbox）**：在子进程 `exec` 用户程序之前，利用 `setrlimit` 系统调用对该进程设置硬约束，包括：
   - `RLIMIT_CPU`：限制 CPU 执行时长，防止死循环。
   - `RLIMIT_AS`：限制进程占用的最大虚拟内存，防止内存泄露或恶意申请。
3. **输出重定向**：将标准输入、标准输出、标准错误重定向到临时文件，防止用户代码直接向控制台打印垃圾信息。

## 4. 后端判题逻辑相关

**Q: 简述一下从用户点击“提交”到看到结果的过程？**
A: 
1. `oj_server` 接收到前端请求，提取题目编号和源代码。
2. 从数据库获取该题目的测试用例（Header/Tail 代码段）。
3. 负载均衡器选择一台可用的 `compile_server`。
4. `oj_server` 向后端发送包含完整代码和资源限制要求的 JSON 请求。
5. `compile_server` 接收请求，生成唯一命名的 `.cpp` 文件并调用 `g++` 编译。
6. 编译成功后，`fork` 子进程并设置资源限制，运行生成的执行文件。
7. 运行结束后，解析退出码或捕获到的信号（如段错误、超时等），将结果封装成 JSON 返回给 `oj_server`。
8. `oj_server` 根据返回结果渲染页面展示给用户。

## 5. 数据库设计相关

**Q: 数据库中有哪些核心表？如何处理高并发下的数据一致性？**
A: 核心表包括：
- `User`：存储用户名、加密密码（Salted MD5）、权限等。
- `Question`：存储题目描述、难度、代码框架及测试桩。
- `UserProgress`：存储用户的答题次数、通过状态等统计信息。
在 C++ 层面对数据库操作加锁或利用 MySQL 自带的事务机制来保证数据的一致性。

## 6. 其他技术点

**Q: 如何保证高并发下生成临时文件不冲突？**
A: 采用“时间戳 + 原子递增 ID”的方式生成唯一文件名（Unique Filename）。这样即使是在同一毫秒内发来的多个请求，由于原子递增 ID 的存在，生成的文件名也绝不会重复。

**Q: 如果后端判题服务器突然宕机，系统如何应对？**
A: `oj_server` 在请求后端失败时会触发异常处理逻辑，将该节点标记为 `Offline`，并重新调用负载均衡算法寻找下一个可用节点进行重试。同时，可以设计一个后台线程定期对离线节点进行心跳检测，若节点恢复则重新将其标记为 `Online`。

**Q: 你的负载均衡算法中，具体的机器状态是如何获取的？**
A: 我们在后端实现了 `HostStatusUtil` 工具类，通过读取 Linux 系统特定的虚拟文件系统和调用系统 API 获取：
1. **CPU 使用率**：解析 `/proc/stat` 文件，计算两次采集之间非空闲时间占总时间的比例。
2. **内存使用率**：调用 `sysinfo()` 系统调用获取 `totalram` 和 `freeram`。
3. **网络负载**：解析 `/proc/net/dev` 获取指定网卡的收发字节数。
4. **连接数**：解析 `/proc/net/tcp` 计算状态为 `ESTABLISHED` (0A) 的连接。
5. **系统平均负载**：直接调用 `getloadavg()` 函数。

**Q: 项目中是如何处理用户登录态的？**
A: 采用传统的 Session 机制。用户登录成功后，服务器生成一个随机的、高强度的 `session_id`，将其存储在服务器端的 `std::map<std::string, std::string>` 中（Key 为 session_id，Value 为用户名），并通过 HTTP Header 的 `Set-Cookie` 发送给浏览器。后续请求通过读取 Cookie 中的 `session_id` 来验证用户身份。

**Q: 为什么在生产环境中需要清理临时文件？你是如何实现的？**
A: 判题过程中会产生大量的 `.cpp`, `.exe`, `.compile_err`, `.stdout` 等中间文件，如果不清理会撑爆磁盘空间。我们在 `compile_run.hpp` 中定义了 `RemoveTempFile` 函数，在一次判题任务的 `END` 标签处（即返回 JSON 结果之前），无论成功还是失败，都会统一调用此函数将该任务对应的所有临时文件删除。